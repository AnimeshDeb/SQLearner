[
  {
    "id": 1,
    "title": "Find High Value Orders",
    "difficulty": "Easy",
    "category": "E-commerce",
    "description": "### Problem\nRetrieve all orders where the total amount is strictly greater than $100.\nReturn the `order_id` and `amount`.\n\n### Table: `orders`\n\n| Column | Type | Description |\n|---|---|---|\n| order_id | INT | Primary Key |\n| amount | DECIMAL | Total order value |\n\n### Example\n\n**Input**\n\n| order_id | amount |\n|---|---|\n| 1 | 50.00 |\n| 2 | 150.00 |\n| 3 | 20.00 |\n\n**Output**\n\n| order_id | amount |\n|---|---|\n| 2 | 150.00 |",
    "correctQuery": "SELECT order_id, amount FROM orders WHERE amount > 100;",
    "sourceTableQuery": "CREATE TABLE orders (order_id INT, amount DECIMAL(10,2)); INSERT INTO orders VALUES (1, 50.00), (2, 150.00), (3, 20.00);",
    "hints": [
      "Use the WHERE clause to filter the rows based on the amount column."
    ]
  },
  {
    "id": 2,
    "title": "Count Employees per Department",
    "difficulty": "Easy",
    "category": "HR",
    "description": "### Problem\nCount how many employees work in each department.\nReturn the `department` name and the count of employees (`emp_count`).\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Employee Name |\n| department | VARCHAR | Department Name |\n\n### Example\n\n**Input**\n\n| id | name | department |\n|---|---|---|\n| 1 | Alice | HR |\n| 2 | Bob | Engineering |\n| 3 | Charlie | HR |\n\n**Output**\n\n| department | emp_count |\n|---|---|\n| Engineering | 1 |\n| HR | 2 |",
    "correctQuery": "SELECT department, COUNT(*) as emp_count FROM employees GROUP BY department;",
    "sourceTableQuery": "CREATE TABLE employees (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO employees VALUES (1, 'Alice', 'HR'), (2, 'Bob', 'Engineering'), (3, 'Charlie', 'HR');",
    "hints": [
      "Use the GROUP BY clause along with the COUNT aggregation function."
    ]
  },
  {
    "id": 3,
    "title": "Users with No Profile Picture",
    "difficulty": "Easy",
    "category": "Social Media",
    "description": "### Problem\nFind users who have not uploaded a profile picture (field is NULL).\nReturn the `username` of these users.\n\n### Table: `users`\n\n| Column | Type | Description |\n|---|---|---|\n| user_id | INT | Primary Key |\n| username | VARCHAR | User handle |\n| profile_pic | VARCHAR | URL to image (nullable) |\n\n### Example\n\n**Input**\n\n| user_id | username | profile_pic |\n|---|---|---|\n| 1 | @jdoe | NULL |\n| 2 | @asmith | 'img.jpg' |\n\n**Output**\n\n| username |\n|---|\n| @jdoe |",
    "correctQuery": "SELECT username FROM users WHERE profile_pic IS NULL;",
    "sourceTableQuery": "CREATE TABLE users (user_id INT, username VARCHAR(50), profile_pic VARCHAR(100)); INSERT INTO users VALUES (1, '@jdoe', NULL), (2, '@asmith', 'img.jpg');",
    "hints": [
      "In SQL, you cannot compare NULL with '=', you must use the 'IS NULL' operator."
    ]
  },
  {
    "id": 4,
    "title": "Highest Transaction",
    "difficulty": "Easy",
    "category": "Fintech",
    "description": "### Problem\nFind the single highest transaction amount recorded today.\nReturn the value as `max(amount)` (or the default aggregation name).\n\n### Table: `transactions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| amount | DECIMAL | Transaction value |\n| transaction_date | TEXT | Date (YYYY-MM-DD) |\n\n### Example\n\n**Input (Assume Today is 2023-10-27)**\n\n| id | amount | transaction_date |\n|---|---|---|\n| 1 | 50.00 | 2023-10-27 |\n| 2 | 200.00 | 2023-10-27 |\n| 3 | 10.00 | 2023-10-26 |\n\n**Output**\n\n| max(amount) |\n|---|\n| 200.00 |",
    "correctQuery": "SELECT MAX(amount) FROM transactions WHERE transaction_date = DATE('now');",
    "sourceTableQuery": "CREATE TABLE transactions (id INT, amount DECIMAL, transaction_date TEXT); INSERT INTO transactions VALUES (1, 50.00, DATE('now')), (2, 200.00, DATE('now')), (3, 10.00, '2020-01-01');",
    "hints": [
      "Use the MAX() function combined with a WHERE clause that filters for DATE('now')."
    ]
  },
  {
    "id": 5,
    "title": "Pending Shipments",
    "difficulty": "Easy",
    "category": "Logistics",
    "description": "### Problem\nList all shipments that have a status of 'Pending'.\nReturn the `shipment_id` and `destination`.\n\n### Table: `shipments`\n\n| Column | Type | Description |\n|---|---|---|\n| shipment_id | INT | Primary Key |\n| destination | VARCHAR | City Name |\n| status | VARCHAR | Status (Pending/Shipped) |\n\n### Example\n\n**Input**\n\n| shipment_id | destination | status |\n|---|---|---|\n| 1 | New York | Shipped |\n| 2 | London | Pending |\n\n**Output**\n\n| shipment_id | destination |\n|---|---|\n| 2 | London |",
    "correctQuery": "SELECT shipment_id, destination FROM shipments WHERE status = 'Pending';",
    "sourceTableQuery": "CREATE TABLE shipments (shipment_id INT, destination VARCHAR(100), status VARCHAR(20)); INSERT INTO shipments VALUES (1, 'New York', 'Shipped'), (2, 'London', 'Pending');",
    "hints": [
      "Use a simple SELECT statement with a WHERE clause filtering for the string 'Pending'."
    ]
  },
  {
    "id": 6,
    "title": "Unique Active Subs",
    "difficulty": "Easy",
    "category": "SaaS",
    "description": "### Problem\nCount the number of unique users who have an active subscription.\n\n### Table: `subscriptions`\n\n| Column | Type | Description |\n|---|---|---|\n| sub_id | INT | Primary Key |\n| user_id | INT | User ID |\n| status | VARCHAR | active/cancelled |\n\n### Example\n\n**Input**\n\n| sub_id | user_id | status |\n|---|---|---|\n| 1 | 101 | active |\n| 2 | 101 | active |\n| 3 | 102 | cancelled |\n\n**Output**\n\n| count |\n|---|\n| 1 |",
    "correctQuery": "SELECT COUNT(DISTINCT user_id) FROM subscriptions WHERE status = 'active';",
    "sourceTableQuery": "CREATE TABLE subscriptions (sub_id INT, user_id INT, status VARCHAR(20)); INSERT INTO subscriptions VALUES (1, 101, 'active'), (2, 101, 'active'), (3, 102, 'cancelled');",
    "hints": [
      "Use COUNT(DISTINCT column_name) to avoid counting the same user twice."
    ]
  },
  {
    "id": 7,
    "title": "Patients Named John",
    "difficulty": "Easy",
    "category": "Healthcare",
    "description": "### Problem\nFind all patients whose first name is 'John'.\nReturn all columns for the matching patients.\n\n### Table: `patients`\n\n| Column | Type | Description |\n|---|---|---|\n| patient_id | INT | Primary Key |\n| name | VARCHAR | Full Name |\n\n### Example\n\n**Input**\n\n| patient_id | name |\n|---|---|\n| 1 | John Doe |\n| 2 | Jane Smith |\n| 3 | Johnny Cash |\n\n**Output**\n\n| patient_id | name |\n|---|---|\n| 1 | John Doe |\n| 3 | Johnny Cash |",
    "correctQuery": "SELECT * FROM patients WHERE name LIKE 'John %';",
    "sourceTableQuery": "CREATE TABLE patients (patient_id INT, name VARCHAR(100)); INSERT INTO patients VALUES (1, 'John Doe'), (2, 'Jane Smith'), (3, 'Johnny Cash');",
    "hints": [
      "Use the LIKE operator with the wildcard '%' to match strings starting with 'John'."
    ]
  },
  {
    "id": 8,
    "title": "Product Categories",
    "difficulty": "Easy",
    "category": "E-commerce",
    "description": "### Problem\nList all unique product categories available in the inventory.\nReturn the `category` column.\n\n### Table: `products`\n\n| Column | Type | Description |\n|---|---|---|\n| product_id | INT | Primary Key |\n| category | VARCHAR | Category Name |\n\n### Example\n\n**Input**\n\n| product_id | category |\n|---|---|\n| 1 | Electronics |\n| 2 | Electronics |\n| 3 | Home |\n\n**Output**\n\n| category |\n|---|\n| Electronics |\n| Home |",
    "correctQuery": "SELECT DISTINCT category FROM products;",
    "sourceTableQuery": "CREATE TABLE products (product_id INT, category VARCHAR(50)); INSERT INTO products VALUES (1, 'Electronics'), (2, 'Electronics'), (3, 'Home');",
    "hints": [
      "The DISTINCT keyword removes duplicate rows from the result set."
    ]
  },
  {
    "id": 9,
    "title": "Specific Departments",
    "difficulty": "Easy",
    "category": "HR",
    "description": "### Problem\nSelect employees who work in either 'Engineering' or 'Sales'.\nReturn the employee `name`.\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Employee Name |\n| department | VARCHAR | Dept Name |\n\n### Example\n\n**Input**\n\n| id | name | department |\n|---|---|---|\n| 1 | A | Engineering |\n| 2 | B | Sales |\n| 3 | C | HR |\n\n**Output**\n\n| name |\n|---|\n| A |\n| B |",
    "correctQuery": "SELECT name FROM employees WHERE department IN ('Engineering', 'Sales');",
    "sourceTableQuery": "CREATE TABLE employees (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO employees VALUES (1, 'A', 'Engineering'), (2, 'B', 'Sales'), (3, 'C', 'HR');",
    "hints": [
      "Use the IN operator to check if a column matches any value in a list."
    ]
  },
  {
    "id": 10,
    "title": "Failed Transactions",
    "difficulty": "Easy",
    "category": "Fintech",
    "description": "### Problem\nFind transactions that failed (success = 0) and were over $50.\nReturn the transaction `id`.\n\n### Table: `transactions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| success | INT | 1 = true, 0 = false |\n| amount | DECIMAL | Value |\n\n### Example\n\n**Input**\n\n| id | success | amount |\n|---|---|---|\n| 1 | 0 | 100.00 |\n| 2 | 0 | 20.00 |\n| 3 | 1 | 200.00 |\n\n**Output**\n\n| id |\n|---|\n| 1 |",
    "correctQuery": "SELECT id FROM transactions WHERE success = 0 AND amount > 50;",
    "sourceTableQuery": "CREATE TABLE transactions (id INT, success BOOLEAN, amount DECIMAL); INSERT INTO transactions VALUES (1, 0, 100.00), (2, 0, 20.00), (3, 1, 200.00);",
    "hints": [
      "Combine two conditions using AND. In SQLite, use 0 for False."
    ]
  },
  {
    "id": 11,
    "title": "Top 3 Posts",
    "difficulty": "Easy",
    "category": "Social Media",
    "description": "### Problem\nGet the top 3 posts with the most likes.\nReturn the `post_id` and `content`.\nThe result should be ordered by `likes` in descending order.\n\n### Table: `posts`\n\n| Column | Type | Description |\n|---|---|---|\n| post_id | INT | Primary Key |\n| content | TEXT | Post body |\n| likes | INT | Like count |\n\n### Example\n\n**Input**\n\n| post_id | content | likes |\n|---|---|---|\n| 1 | Hello | 10 |\n| 2 | World | 50 |\n| 3 | Code | 5 |\n| 4 | SQL | 20 |\n\n**Output**\n\n| post_id | content |\n|---|---|\n| 2 | World |\n| 4 | SQL |\n| 1 | Hello |",
    "correctQuery": "SELECT post_id, content FROM posts ORDER BY likes DESC LIMIT 3;",
    "sourceTableQuery": "CREATE TABLE posts (post_id INT, content TEXT, likes INT); INSERT INTO posts VALUES (1, 'Hello', 10), (2, 'World', 50), (3, 'Code', 5), (4, 'SQL', 20);",
    "hints": [
      "Use ORDER BY ... DESC to sort highest to lowest, and LIMIT to restrict the rows."
    ]
  },
  {
    "id": 12,
    "title": "Driver Assignment",
    "difficulty": "Easy",
    "category": "Logistics",
    "description": "### Problem\nReturn the `driver_name` for all shipments.\nHowever, if the driver is NULL, return 'Unassigned' instead of NULL.\n\n### Table: `shipments`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| driver_name | VARCHAR | Name (Nullable) |\n\n### Example\n\n**Input**\n\n| id | driver_name |\n|---|---|\n| 1 | John |\n| 2 | NULL |\n\n**Output**\n\n| driver_name |\n|---|\n| John |\n| Unassigned |",
    "correctQuery": "SELECT COALESCE(driver_name, 'Unassigned') FROM shipments;",
    "sourceTableQuery": "CREATE TABLE shipments (id INT, driver_name VARCHAR(50)); INSERT INTO shipments VALUES (1, 'John'), (2, NULL);",
    "hints": [
      "The COALESCE() function returns the first non-null value in its argument list."
    ]
  },
  {
    "id": 13,
    "title": "User Full Names",
    "difficulty": "Easy",
    "category": "SaaS",
    "description": "### Problem\nConcatenate `first_name` and `last_name` into a single column called `full_name`.\nThere should be a single space between the first and last name.\n\n### Table: `users`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| first_name | VARCHAR | First Name |\n| last_name | VARCHAR | Last Name |\n\n### Example\n\n**Input**\n\n| id | first_name | last_name |\n|---|---|---|\n| 1 | John | Doe |\n\n**Output**\n\n| full_name |\n|---|\n| John Doe |",
    "correctQuery": "SELECT first_name || ' ' || last_name as full_name FROM users;",
    "sourceTableQuery": "CREATE TABLE users (id INT, first_name VARCHAR(50), last_name VARCHAR(50)); INSERT INTO users VALUES (1, 'John', 'Doe');",
    "hints": [
      "In SQLite, use the double pipe '||' operator to concatenate strings."
    ]
  },
  {
    "id": 14,
    "title": "Recent Admissions",
    "difficulty": "Easy",
    "category": "Healthcare",
    "description": "### Problem\nFind patients admitted in the year 2023.\nReturn the `patient_id`.\n\n### Table: `admissions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| patient_id | INT | Patient ID |\n| admission_date | TEXT | Date (YYYY-MM-DD) |\n\n### Example\n\n**Input**\n\n| id | patient_id | admission_date |\n|---|---|---|\n| 1 | 101 | 2023-05-01 |\n| 2 | 102 | 2022-12-15 |\n\n**Output**\n\n| patient_id |\n|---|\n| 101 |",
    "correctQuery": "SELECT patient_id FROM admissions WHERE strftime('%Y', admission_date) = '2023';",
    "sourceTableQuery": "CREATE TABLE admissions (id INT, patient_id INT, admission_date TEXT); INSERT INTO admissions VALUES (1, 101, '2023-05-01'), (2, 102, '2022-12-15');",
    "hints": [
      "Use the strftime('%Y', date_column) function to extract the year as a string."
    ]
  },
  {
    "id": 15,
    "title": "Expensive Categories",
    "difficulty": "Easy",
    "category": "E-commerce",
    "description": "### Problem\nFind categories where the average product price is strictly greater than $50.\nReturn the `category` name.\n\n### Table: `products`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| category | VARCHAR | Category Name |\n| price | DECIMAL | Product Price |\n\n### Example\n\n**Input**\n\n| id | category | price |\n|---|---|---|\n| 1 | A | 40 |\n| 2 | A | 50 |\n| 3 | B | 100 |\n\n**Output**\n\n| category |\n|---|\n| B |",
    "correctQuery": "SELECT category FROM products GROUP BY category HAVING AVG(price) > 50;",
    "sourceTableQuery": "CREATE TABLE products (id INT, category VARCHAR(50), price DECIMAL); INSERT INTO products VALUES (1, 'A', 40), (2, 'A', 50), (3, 'B', 100);",
    "hints": [
      "Use the HAVING clause to filter groups created by GROUP BY."
    ]
  },
  {
    "id": 16,
    "title": "Non-IT Staff",
    "difficulty": "Easy",
    "category": "HR",
    "description": "### Problem\nSelect all employees who are NOT in the IT department.\nReturn the employee `name`.\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Employee Name |\n| department | VARCHAR | Department |\n\n### Example\n\n**Input**\n\n| id | name | department |\n|---|---|---|\n| 1 | John | IT |\n| 2 | Jane | HR |\n\n**Output**\n\n| name |\n|---|\n| Jane |",
    "correctQuery": "SELECT name FROM employees WHERE department != 'IT';",
    "sourceTableQuery": "CREATE TABLE employees (id INT, name VARCHAR(50), department VARCHAR(50)); INSERT INTO employees VALUES (1, 'John', 'IT'), (2, 'Jane', 'HR');",
    "hints": [
      "Use the '!=' or '<>' operator to find records that do not match a value."
    ]
  },
  {
    "id": 17,
    "title": "Q1 Transactions",
    "difficulty": "Easy",
    "category": "Fintech",
    "description": "### Problem\nSelect transactions that occurred between Jan 1 and Mar 31, 2023 (inclusive).\nReturn all columns.\n\n### Table: `transactions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| date | TEXT | Date (YYYY-MM-DD) |\n\n### Example\n\n**Input**\n\n| id | date |\n|---|---|\n| 1 | 2023-01-15 |\n| 2 | 2023-04-01 |\n\n**Output**\n\n| id | date |\n|---|---|\n| 1 | 2023-01-15 |",
    "correctQuery": "SELECT * FROM transactions WHERE date BETWEEN '2023-01-01' AND '2023-03-31';",
    "sourceTableQuery": "CREATE TABLE transactions (id INT, date TEXT); INSERT INTO transactions VALUES (1, '2023-01-15'), (2, '2023-04-01');",
    "hints": [
      "The BETWEEN operator includes both the start and end values."
    ]
  },
  {
    "id": 18,
    "title": "Post Type Classification",
    "difficulty": "Easy",
    "category": "Social Media",
    "description": "### Problem\nReturn `post_id` and a column `Type` that says 'Short' if length < 100 chars, else 'Long'.\n\n### Table: `posts`\n\n| Column | Type | Description |\n|---|---|---|\n| post_id | INT | Primary Key |\n| content | TEXT | Post body |\n\n### Example\n\n**Input**\n\n| post_id | content |\n|---|---|\n| 1 | Hi |\n| 2 | [Very long text...] |\n\n**Output**\n\n| post_id | Type |\n|---|---|\n| 1 | Short |\n| 2 | Long |",
    "correctQuery": "SELECT post_id, CASE WHEN LENGTH(content) < 100 THEN 'Short' ELSE 'Long' END as Type FROM posts;",
    "sourceTableQuery": "CREATE TABLE posts (post_id INT, content TEXT); INSERT INTO posts VALUES (1, 'Hi'), (2, 'This is a very long post that exceeds one hundred characters and keeps going and going and going and going...');",
    "hints": [
      "Use a CASE statement (CASE WHEN ... THEN ... ELSE ... END) for conditional logic."
    ]
  },
  {
    "id": 19,
    "title": "Weight Integer",
    "difficulty": "Easy",
    "category": "Logistics",
    "description": "### Problem\nThe weight column is decimal. Return it cast as an integer.\nReturn the column as `weight`.\n\n### Table: `packages`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| weight | DECIMAL | Weight in kg |\n\n### Example\n\n**Input**\n\n| id | weight |\n|---|---|\n| 1 | 12.55 |\n\n**Output**\n\n| weight |\n|---|\n| 12 |",
    "correctQuery": "SELECT CAST(weight AS INTEGER) FROM packages;",
    "sourceTableQuery": "CREATE TABLE packages (id INT, weight DECIMAL(5,2)); INSERT INTO packages VALUES (1, 12.55);",
    "hints": [
      "Use the CAST(column AS type) function to change the data type."
    ]
  },
  {
    "id": 20,
    "title": "Round Usage Data",
    "difficulty": "Easy",
    "category": "SaaS",
    "description": "### Problem\nReturn the `data_usage_mb` column rounded to the nearest whole number.\n\n### Table: `user_stats`\n\n| Column | Type | Description |\n|---|---|---|\n| user_id | INT | Primary Key |\n| data_usage_mb | DECIMAL | Usage in MB |\n\n### Example\n\n**Input**\n\n| user_id | data_usage_mb |\n|---|---|\n| 1 | 100.6 |\n\n**Output**\n\n| round(data_usage_mb) |\n|---|\n| 101.0 |",
    "correctQuery": "SELECT ROUND(data_usage_mb) FROM user_stats;",
    "sourceTableQuery": "CREATE TABLE user_stats (user_id INT, data_usage_mb DECIMAL); INSERT INTO user_stats VALUES (1, 100.6);",
    "hints": [
      "The ROUND() function does exactly what you need."
    ]
  },
  {
    "id": 21,
    "title": "Employees with Same Manager",
    "difficulty": "Medium",
    "category": "HR",
    "description": "### Problem\nFind pairs of employees who share the same manager. Return both names.\nThe result should exclude pairs of the same person with themselves, and each pair should only appear once (e.g., A-B, not B-A).\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Employee Name |\n| manager_id | INT | ID of Manager |\n\n### Example\n\n**Input**\n\n| id | name | manager_id |\n|---|---|---|\n| 1 | A | 10 |\n| 2 | B | 10 |\n| 3 | C | 20 |\n\n**Output**\n\n| name | name |\n|---|---|\n| A | B |",
    "correctQuery": "SELECT e1.name, e2.name FROM employees e1 JOIN employees e2 ON e1.manager_id = e2.manager_id WHERE e1.id < e2.id;",
    "sourceTableQuery": "CREATE TABLE employees (id INT, name VARCHAR(50), manager_id INT); INSERT INTO employees VALUES (1, 'A', 10), (2, 'B', 10), (3, 'C', 20);",
    "hints": [
      "Use a Self-Join by joining the 'employees' table to itself on manager_id.",
      "Add a condition like e1.id < e2.id to ensure you don't match an employee to themselves or get duplicate pairs."
    ]
  },
  {
    "id": 22,
    "title": "Customers Without Orders",
    "difficulty": "Medium",
    "category": "E-commerce",
    "description": "### Problem\nFind customers who have signed up but never placed an order.\nReturn the customer `name`.\n\n### Table: `customers`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Name |\n\n### Table: `orders`\n\n| Column | Type | Description |\n|---|---|---|\n| order_id | INT | Primary Key |\n| customer_id | INT | FK to customers |\n\n### Example\n\n**Input**\n\n`customers` table:\n| id | name |\n|---|---|\n| 1 | Alice |\n| 2 | Bob |\n\n`orders` table:\n| order_id | customer_id |\n|---|---|\n| 100 | 1 |\n\n**Output**\n\n| name |\n|---|\n| Bob |",
    "correctQuery": "SELECT c.name FROM customers c LEFT JOIN orders o ON c.id = o.customer_id WHERE o.order_id IS NULL;",
    "sourceTableQuery": "CREATE TABLE customers (id INT, name VARCHAR(50)); CREATE TABLE orders (order_id INT, customer_id INT); INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'); INSERT INTO orders VALUES (100, 1);",
    "hints": [
      "Use a LEFT JOIN from customers to orders to keep all customers.",
      "Filter the results where the order_id (from the right table) IS NULL."
    ]
  },
  {
    "id": 23,
    "title": "Payment Due Date",
    "difficulty": "Medium",
    "category": "Fintech",
    "description": "### Problem\nCalculate the due date for invoices, which is exactly 30 days after the invoice_date.\nReturn the `invoice_id` and the `due_date`.\n\n### Table: `invoices`\n\n| Column | Type | Description |\n|---|---|---|\n| invoice_id | INT | Primary Key |\n| invoice_date | TEXT | Date (YYYY-MM-DD) |\n\n### Example\n\n**Input**\n\n| invoice_id | invoice_date |\n|---|---|\n| 1 | 2023-01-01 |\n\n**Output**\n\n| invoice_id | due_date |\n|---|---|\n| 1 | 2023-01-31 |",
    "correctQuery": "SELECT invoice_id, DATE(invoice_date, '+30 days') as due_date FROM invoices;",
    "sourceTableQuery": "CREATE TABLE invoices (invoice_id INT, invoice_date TEXT); INSERT INTO invoices VALUES (1, '2023-01-01');",
    "hints": [
      "Use the SQLite DATE() function.",
      "Use the modifier syntax '+30 days' as the second argument to the DATE function."
    ]
  },
  {
    "id": 24,
    "title": "Above Average Users",
    "difficulty": "Medium",
    "category": "SaaS",
    "description": "### Problem\nFind users whose login count is strictly higher than the average login count of all users.\nReturn the `user_id`.\n\n### Table: `user_stats`\n\n| Column | Type | Description |\n|---|---|---|\n| user_id | INT | Primary Key |\n| login_count | INT | Total Logins |\n\n### Example\n\n**Input**\n\n| user_id | login_count |\n|---|---|\n| 1 | 10 |\n| 2 | 20 |\n| 3 | 5 |\n\n*(Average is 11.66)*\n\n**Output**\n\n| user_id |\n|---|\n| 2 |",
    "correctQuery": "SELECT user_id FROM user_stats WHERE login_count > (SELECT AVG(login_count) FROM user_stats);",
    "sourceTableQuery": "CREATE TABLE user_stats (user_id INT, login_count INT); INSERT INTO user_stats VALUES (1, 10), (2, 20), (3, 5);",
    "hints": [
      "Calculate the average login count using a subquery.",
      "Use that subquery in the WHERE clause: login_count > (SELECT ...)."
    ]
  },
  {
    "id": 25,
    "title": "Warehouse Capacity",
    "difficulty": "Medium",
    "category": "Logistics",
    "description": "### Problem\nCategorize warehouses based on usage percentage:\n* 'Full' if usage > 90\n* 'Empty' if usage < 10\n* 'Normal' otherwise\n\nReturn `warehouse_id` and the new `status` column.\n\n### Table: `warehouses`\n\n| Column | Type | Description |\n|---|---|---|\n| warehouse_id | INT | Primary Key |\n| usage_pct | INT | 0-100 |\n\n### Example\n\n**Input**\n\n| warehouse_id | usage_pct |\n|---|---|\n| 1 | 95 |\n| 2 | 5 |\n| 3 | 50 |\n\n**Output**\n\n| warehouse_id | status |\n|---|---|\n| 1 | Full |\n| 2 | Empty |\n| 3 | Normal |",
    "correctQuery": "SELECT warehouse_id, CASE WHEN usage_pct > 90 THEN 'Full' WHEN usage_pct < 10 THEN 'Empty' ELSE 'Normal' END as status FROM warehouses;",
    "sourceTableQuery": "CREATE TABLE warehouses (warehouse_id INT, usage_pct INT); INSERT INTO warehouses VALUES (1, 95), (2, 5), (3, 50);",
    "hints": [
      "Use a CASE statement to handle conditional logic in the SELECT clause.",
      "Remember that CASE statements evaluate conditions in order, top to bottom."
    ]
  },
  {
    "id": 26,
    "title": "Hashtag Extraction",
    "difficulty": "Medium",
    "category": "Social Media",
    "description": "### Problem\nFind posts that contain the hashtag '#sql'.\nReturn the entire row.\n\n### Table: `posts`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| content | TEXT | Post body |\n\n### Example\n\n**Input**\n\n| id | content |\n|---|---|\n| 1 | I love #sql coding |\n| 2 | Python is cool |\n\n**Output**\n\n| id | content |\n|---|---|\n| 1 | I love #sql coding |",
    "correctQuery": "SELECT * FROM posts WHERE content LIKE '%#sql%';",
    "sourceTableQuery": "CREATE TABLE posts (id INT, content TEXT); INSERT INTO posts VALUES (1, 'I love #sql coding'), (2, 'Python is cool');",
    "hints": [
      "Use the LIKE operator to perform partial string matching.",
      "Surround the search term with '%' wildcards to match it anywhere in the text."
    ]
  },
  {
    "id": 27,
    "title": "All People List",
    "difficulty": "Medium",
    "category": "Healthcare",
    "description": "### Problem\nProduce a single list of names containing both doctors and patients.\nReturn the column as `name`.\n\n### Table: `doctors`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Name |\n\n### Table: `patients`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Name |\n\n### Example\n\n**Input**\n\n| id | name |\n|---|---|\n| 1 | Dr. House |\n\n| id | name |\n|---|---|\n| 1 | Patient Zero |\n\n**Output**\n\n| name |\n|---|\n| Dr. House |\n| Patient Zero |",
    "correctQuery": "SELECT name FROM doctors UNION SELECT name FROM patients;",
    "sourceTableQuery": "CREATE TABLE doctors (id INT, name VARCHAR(50)); CREATE TABLE patients (id INT, name VARCHAR(50)); INSERT INTO doctors VALUES (1, 'Dr. House'); INSERT INTO patients VALUES (1, 'Patient Zero');",
    "hints": [
      "Use the UNION operator to combine the results of two SELECT statements.",
      "Ensure both SELECT statements return the same number of columns with the same data types."
    ]
  },
  {
    "id": 28,
    "title": "Departments with Employees",
    "difficulty": "Medium",
    "category": "HR",
    "description": "### Problem\nFind departments that have at least one employee using `EXISTS`.\nReturn the `dept_name`.\n\n### Table: `departments`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| dept_name | VARCHAR | Name |\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| dept_id | INT | FK to Dept |\n\n### Example\n\n**Input**\n\n| id | dept_name |\n|---|---|\n| 1 | IT |\n| 2 | HR |\n\n| id | dept_id |\n|---|---|\n| 100 | 1 |\n\n**Output**\n\n| dept_name |\n|---|\n| IT |",
    "correctQuery": "SELECT dept_name FROM departments d WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id);",
    "sourceTableQuery": "CREATE TABLE departments (id INT, dept_name VARCHAR(50)); CREATE TABLE employees (id INT, dept_id INT); INSERT INTO departments VALUES (1, 'IT'), (2, 'HR'); INSERT INTO employees VALUES (100, 1);",
    "hints": [
      "Use the EXISTS clause to check if a subquery returns any rows.",
      "Use a correlated subquery that references the department ID from the outer query."
    ]
  },
  {
    "id": 29,
    "title": "Second Most Recent Order",
    "difficulty": "Medium",
    "category": "E-commerce",
    "description": "### Problem\nFind the second most recent order for a specific customer (ID 1).\nReturn the `order_id`.\n\n### Table: `orders`\n\n| Column | Type | Description |\n|---|---|---|\n| order_id | INT | Primary Key |\n| customer_id | INT | Customer ID |\n| order_date | TEXT | YYYY-MM-DD |\n\n### Example\n\n**Input**\n\n| order_id | customer_id | order_date |\n|---|---|---|\n| 1 | 1 | 2023-01-01 |\n| 2 | 1 | 2023-01-05 |\n| 3 | 1 | 2023-01-10 |\n\n**Output**\n\n| order_id |\n|---|\n| 2 |",
    "correctQuery": "SELECT order_id FROM orders WHERE customer_id = 1 ORDER BY order_date DESC LIMIT 1 OFFSET 1;",
    "sourceTableQuery": "CREATE TABLE orders (order_id INT, customer_id INT, order_date TEXT); INSERT INTO orders VALUES (1, 1, '2023-01-01'), (2, 1, '2023-01-05'), (3, 1, '2023-01-10');",
    "hints": [
      "Use ORDER BY order_date DESC to sort the orders from newest to oldest.",
      "Use LIMIT 1 OFFSET 1 to skip the first record (most recent) and take the next one."
    ]
  },
  {
    "id": 30,
    "title": "Running Balance",
    "difficulty": "Medium",
    "category": "Fintech",
    "description": "### Problem\nCalculate the running total of transaction amounts **for each transaction** in the table.\nThe running total should be calculated based on the order of `transaction_date`.\n\n### Table: `transactions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| amount | DECIMAL | Value |\n| transaction_date | TEXT | YYYY-MM-DD |\n\n### Example\n\n**Input**\n\n| id | amount | transaction_date |\n|---|---|---|\n| 1 | 100 | 2023-01-01 |\n| 2 | 50 | 2023-01-02 |\n| 3 | -20 | 2023-01-03 |\n\n**Output**\n\n| transaction_date | amount | running_total |\n|---|---|---|\n| 2023-01-01 | 100 | 100 |\n| 2023-01-02 | 50 | 150 |\n| 2023-01-03 | -20 | 130 |",
    "correctQuery": "SELECT transaction_date, amount, SUM(amount) OVER (ORDER BY transaction_date) as running_total FROM transactions;",
    "sourceTableQuery": "CREATE TABLE transactions (id INT, amount DECIMAL, transaction_date TEXT); INSERT INTO transactions VALUES (1, 100, '2023-01-01'), (2, 50, '2023-01-02'), (3, -20, '2023-01-03');",
    "hints": [
      "Use a Window Function to calculate an aggregate across a set of table rows.",
      "The syntax is SUM(amount) OVER (ORDER BY transaction_date)."
    ]
  },
  {
    "id": 31,
    "title": "Top Customers CTE",
    "difficulty": "Medium",
    "category": "SaaS",
    "description": "### Problem\nUse a CTE to find customers who spent more than $500, then select their names.\n\n### Table: `customers`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Name |\n\n### Table: `payments`\n\n| Column | Type | Description |\n|---|---|---|\n| customer_id | INT | FK to Customer |\n| amount | DECIMAL | Payment |\n\n### Example\n\n**Input**\n\n| id | name |\n|---|---|\n| 1 | Big Spender |\n| 2 | Small Spender |\n\n| customer_id | amount |\n|---|---|\n| 1 | 600 |\n| 2 | 50 |\n\n**Output**\n\n| name |\n|---|\n| Big Spender |",
    "correctQuery": "WITH HighSpenders AS (SELECT customer_id FROM payments GROUP BY customer_id HAVING SUM(amount) > 500) SELECT name FROM customers c JOIN HighSpenders h ON c.id = h.customer_id;",
    "sourceTableQuery": "CREATE TABLE customers (id INT, name VARCHAR(50)); CREATE TABLE payments (customer_id INT, amount DECIMAL); INSERT INTO customers VALUES (1, 'Big Spender'), (2, 'Small Spender'); INSERT INTO payments VALUES (1, 600), (2, 50);",
    "hints": [
      "Define the CTE using the 'WITH' clause.",
      "Join the CTE table to the customers table in the final SELECT statement."
    ]
  },
  {
    "id": 32,
    "title": "Average Weight Handling Nulls",
    "difficulty": "Medium",
    "category": "Logistics",
    "description": "### Problem\nCalculate average package weight.\nTreat NULL weights as 0 for the calculation.\n\n### Table: `packages`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| weight | DECIMAL | Weight (nullable) |\n\n### Example\n\n**Input**\n\n| id | weight |\n|---|---|\n| 1 | 10 |\n| 2 | NULL |\n| 3 | 20 |\n\n**Output**\n\n| avg_weight |\n|---|\n| 10.0 |\n*(Calculation: (10 + 0 + 20) / 3 = 10)*",
    "correctQuery": "SELECT AVG(COALESCE(weight, 0)) FROM packages;",
    "sourceTableQuery": "CREATE TABLE packages (id INT, weight DECIMAL); INSERT INTO packages VALUES (1, 10), (2, NULL), (3, 20);",
    "hints": [
      "Use COALESCE(weight, 0) to convert NULLs to 0.",
      "Wrap that function inside the AVG() function."
    ]
  },
  {
    "id": 33,
    "title": "Friend Combinations",
    "difficulty": "Medium",
    "category": "Social Media",
    "description": "### Problem\nGenerate all possible pairs of users for a 'Suggested Friends' feature (Cross Join).\nReturn `username` from table 1 and `username` from table 2.\nExclude pairs where a user is matched with themselves.\n\n### Table: `users`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| username | VARCHAR | Name |\n\n### Example\n\n**Input**\n\n| id | username |\n|---|---|\n| 1 | A |\n| 2 | B |\n\n**Output**\n\n| username | username |\n|---|---|\n| A | B |\n| B | A |",
    "correctQuery": "SELECT u1.username, u2.username FROM users u1 CROSS JOIN users u2 WHERE u1.id != u2.id;",
    "sourceTableQuery": "CREATE TABLE users (id INT, username VARCHAR(50)); INSERT INTO users VALUES (1, 'A'), (2, 'B');",
    "hints": [
      "Use a CROSS JOIN to create a Cartesian product (every row combined with every other row).",
      "Add a WHERE clause to exclude pairs where a user is matched with themselves."
    ]
  },
  {
    "id": 34,
    "title": "Doctor Patient Count",
    "difficulty": "Medium",
    "category": "Healthcare",
    "description": "### Problem\nList all doctors and the number of patients they are assigned to.\nInclude doctors with 0 patients.\nReturn `name` and `count`.\n\n### Table: `doctors`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Name |\n\n### Table: `patients`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| doctor_id | INT | FK to Doctor |\n\n### Example\n\n**Input**\n\n| id | name |\n|---|---|\n| 1 | Dr. Cox |\n| 2 | Dr. Kelso |\n\n| id | doctor_id |\n|---|---|\n| 101 | 1 |\n\n**Output**\n\n| name | count |\n|---|---|\n| Dr. Cox | 1 |\n| Dr. Kelso | 0 |",
    "correctQuery": "SELECT d.name, COUNT(p.id) FROM doctors d LEFT JOIN patients p ON d.id = p.doctor_id GROUP BY d.name;",
    "sourceTableQuery": "CREATE TABLE doctors (id INT, name VARCHAR(50)); CREATE TABLE patients (id INT, doctor_id INT); INSERT INTO doctors VALUES (1, 'Dr. Cox'), (2, 'Dr. Kelso'); INSERT INTO patients VALUES (101, 1);",
    "hints": [
      "Use a LEFT JOIN starting from the doctors table to ensure all doctors are included.",
      "Count the patient IDs (which will be NULL for doctors with no patients) and GROUP BY doctor name."
    ]
  },
  {
    "id": 35,
    "title": "List Ordered Products",
    "difficulty": "Medium",
    "category": "E-commerce",
    "description": "### Problem\nFor each order, return a comma-separated string of product names.\nThe result column should be named `list`.\n\n### Table: `order_items`\n\n| Column | Type | Description |\n|---|---|---|\n| order_id | INT | Order ID |\n| product_name | TEXT | Name |\n\n### Example\n\n**Input**\n\n| order_id | product_name |\n|---|---|\n| 1 | Apple |\n| 1 | Banana |\n| 2 | Orange |\n\n**Output**\n\n| order_id | list |\n|---|---|\n| 1 | Apple, Banana |\n| 2 | Orange |",
    "correctQuery": "SELECT order_id, GROUP_CONCAT(product_name, ', ') FROM order_items GROUP BY order_id;",
    "sourceTableQuery": "CREATE TABLE order_items (order_id INT, product_name TEXT); INSERT INTO order_items VALUES (1, 'Apple'), (1, 'Banana'), (2, 'Orange');",
    "hints": [
      "Use the GROUP_CONCAT function to combine multiple row values into a single string.",
      "Don't forget to GROUP BY the order_id."
    ]
  },
  {
    "id": 36,
    "title": "Days Since Transaction",
    "difficulty": "Medium",
    "category": "Fintech",
    "description": "### Problem\nCalculate how many days have passed since each transaction relative to 'now'.\nReturn the `id` and the `days_passed` as an integer.\n\n### Table: `transactions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| transaction_date | TEXT | YYYY-MM-DD |\n\n### Example\n\n**Input (Assume Today is 2023-10-30)**\n\n| id | transaction_date |\n|---|---|\n| 1 | 2023-10-01 |\n\n**Output**\n\n| id | days_passed |\n|---|---|\n| 1 | 29 |",
    "correctQuery": "SELECT id, CAST(julianday('now') - julianday(transaction_date) AS INTEGER) as days_passed FROM transactions;",
    "sourceTableQuery": "CREATE TABLE transactions (id INT, transaction_date TEXT); INSERT INTO transactions VALUES (1, '2023-01-01');",
    "hints": [
      "In SQLite, use julianday() to convert dates to a number before subtracting them.",
      "Cast the result to an INTEGER to get whole days."
    ]
  },
  {
    "id": 37,
    "title": "Active During Date",
    "difficulty": "Medium",
    "category": "SaaS",
    "description": "### Problem\nFind subscriptions that were active on '2023-06-01'.\nA subscription is active if the target date is between `start_date` and `end_date` (inclusive).\n\n### Table: `subscriptions`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| start_date | TEXT | YYYY-MM-DD |\n| end_date | TEXT | YYYY-MM-DD |\n\n### Example\n\n**Input**\n\n| id | start_date | end_date |\n|---|---|---|\n| 1 | 2023-01-01 | 2023-12-31 |\n| 2 | 2023-08-01 | 2023-12-31 |\n\n**Output**\n\n| id |\n|---|\n| 1 |",
    "correctQuery": "SELECT * FROM subscriptions WHERE start_date <= '2023-06-01' AND end_date >= '2023-06-01';",
    "sourceTableQuery": "CREATE TABLE subscriptions (id INT, start_date TEXT, end_date TEXT); INSERT INTO subscriptions VALUES (1, '2023-01-01', '2023-12-31'), (2, '2023-08-01', '2023-12-31');",
    "hints": [
      "The subscription must have started on or before the target date.",
      "The subscription must have ended on or after the target date."
    ]
  },
  {
    "id": 38,
    "title": "Odd Numbered Shelves",
    "difficulty": "Medium",
    "category": "Logistics",
    "description": "### Problem\nSelect items stored on odd-numbered shelves.\nReturn the entire row.\n\n### Table: `inventory`\n\n| Column | Type | Description |\n|---|---|---|\n| item_id | INT | Primary Key |\n| shelf_number | INT | Number |\n\n### Example\n\n**Input**\n\n| item_id | shelf_number |\n|---|---|\n| 1 | 1 |\n| 2 | 2 |\n| 3 | 5 |\n\n**Output**\n\n| item_id | shelf_number |\n|---|---|\n| 1 | 1 |\n| 3 | 5 |",
    "correctQuery": "SELECT * FROM inventory WHERE shelf_number % 2 != 0;",
    "sourceTableQuery": "CREATE TABLE inventory (item_id INT, shelf_number INT); INSERT INTO inventory VALUES (1, 1), (2, 2), (3, 5);",
    "hints": [
      "Use the modulo operator (%) to find the remainder of division by 2.",
      "If the remainder is not 0, the number is odd."
    ]
  },
  {
    "id": 39,
    "title": "Highest Paid in Dept",
    "difficulty": "Medium",
    "category": "HR",
    "description": "### Problem\nFind the highest salary in each department.\nReturn the `department` and the `max(salary)`.\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| department | VARCHAR | Name |\n| salary | INT | Amount |\n\n### Example\n\n**Input**\n\n| id | department | salary |\n|---|---|---|\n| 1 | HR | 50000 |\n| 2 | HR | 60000 |\n| 3 | IT | 80000 |\n\n**Output**\n\n| department | max(salary) |\n|---|---|\n| HR | 60000 |\n| IT | 80000 |",
    "correctQuery": "SELECT department, MAX(salary) FROM employees GROUP BY department;",
    "sourceTableQuery": "CREATE TABLE employees (id INT, department VARCHAR(50), salary INT); INSERT INTO employees VALUES (1, 'HR', 50000), (2, 'HR', 60000), (3, 'IT', 80000);",
    "hints": [
      "Use GROUP BY to organize records by department.",
      "Use the MAX() aggregation function on the salary column."
    ]
  },
  {
    "id": 40,
    "title": "Posts per Month",
    "difficulty": "Medium",
    "category": "Social Media",
    "description": "### Problem\nCount the number of posts created in each month of 2023.\nFormat the month as 'YYYY-MM'.\n\n### Table: `posts`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| created_at | TEXT | Date (YYYY-MM-DD) |\n\n### Example\n\n**Input**\n\n| id | created_at |\n|---|---|\n| 1 | 2023-01-15 |\n| 2 | 2023-01-20 |\n| 3 | 2023-02-10 |\n\n**Output**\n\n| month | count |\n|---|---|\n| 2023-01 | 2 |\n| 2023-02 | 1 |",
    "correctQuery": "SELECT strftime('%Y-%m', created_at) as month, COUNT(*) FROM posts WHERE created_at LIKE '2023%' GROUP BY 1;",
    "sourceTableQuery": "CREATE TABLE posts (id INT, created_at TEXT); INSERT INTO posts VALUES (1, '2023-01-15'), (2, '2023-01-20'), (3, '2023-02-10');",
    "hints": [
      "Use strftime('%Y-%m', column_name) to format the date string.",
      "Group by the formatted month string."
    ]
  },
  {
    "id": 41,
    "title": "Manager Hierarchy",
    "difficulty": "Hard",
    "category": "HR",
    "description": "### Problem\nFind the management chain for Employee ID 10 (Employee -> Manager -> Manager's Manager...).\nReturn all columns for the chain.\n\n### Table: `employees`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| name | VARCHAR | Name |\n| manager_id | INT | Manager ID |\n\n### Example\n\n**Input**\n\n| id | name | manager_id |\n|---|---|---|\n| 1 | CEO | NULL |\n| 5 | VP | 1 |\n| 10 | Manager | 5 |\n\n**Output**\n\n| id | name | manager_id |\n|---|---|---|\n| 10 | Manager | 5 |\n| 5 | VP | 1 |\n| 1 | CEO | NULL |",
    "correctQuery": "WITH RECURSIVE ManagementChain AS (SELECT id, name, manager_id FROM employees WHERE id = 10 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN ManagementChain m ON e.id = m.manager_id) SELECT * FROM ManagementChain;",
    "sourceTableQuery": "CREATE TABLE employees (id INT, name VARCHAR(50), manager_id INT); INSERT INTO employees VALUES (1, 'CEO', NULL), (5, 'VP', 1), (10, 'Manager', 5);",
    "hints": [
      "Use a Recursive CTE (WITH RECURSIVE) to traverse the hierarchy.",
      "The first part of the CTE selects the starting employee; the second part joins the employee table to the CTE result to find the manager."
    ]
  },
  {
    "id": 42,
    "title": "3-Day Moving Average",
    "difficulty": "Hard",
    "category": "Fintech",
    "description": "### Problem\nCalculate the 3-day moving average of transaction volume **for each day** in the dataset.\n\nThe moving average should include the **current day and the previous two days**. If there are fewer than 2 previous days (e.g., the first day of data), calculate the average of the available days.\n\nReturn the result ordered by date.\n\n### Table: `daily_sales`\n\n| Column | Type | Description |\n|---|---|---|\n| date | TEXT | YYYY-MM-DD |\n| amount | DECIMAL | Sales |\n\n### Example\n\n**Input**\n\n| date | amount |\n|---|---|\n| 2023-01-01 | 10 |\n| 2023-01-02 | 20 |\n| 2023-01-03 | 30 |\n| 2023-01-04 | 40 |\n\n**Output**\n\n| date | amount | moving_avg |\n|---|---|---|\n| 2023-01-01 | 10 | 10.0 |\n| 2023-01-02 | 20 | 15.0 |\n| 2023-01-03 | 30 | 20.0 |\n| 2023-01-04 | 40 | 30.0 |\n\n**Explanation**\n* Jan 1: (10)/1 = 10\n* Jan 2: (10+20)/2 = 15\n* Jan 3: (10+20+30)/3 = 20\n* Jan 4: (20+30+40)/3 = 30 (Window slides)",
    "correctQuery": "SELECT date, amount, AVG(amount) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg FROM daily_sales;",
    "sourceTableQuery": "CREATE TABLE daily_sales (date TEXT, amount DECIMAL); INSERT INTO daily_sales VALUES ('2023-01-01', 10), ('2023-01-02', 20), ('2023-01-03', 30), ('2023-01-04', 40);",
    "hints": [
      "Use a Window function with the ROWS frame clause.",
      "ROWS BETWEEN 2 PRECEDING AND CURRENT ROW will include the current day and the previous two days."
    ]
  },
  {
    "id": 43,
    "title": "Consecutive Logins",
    "difficulty": "Hard",
    "category": "SaaS",
    "description": "### Problem\nIdentify users who have logged in for 3 consecutive days.\nReturn the `user_id`.\n\n### Table: `user_logins`\n\n| Column | Type | Description |\n|---|---|---|\n| user_id | INT | User ID |\n| login_date | TEXT | YYYY-MM-DD |\n\n### Example\n\n**Input**\n\n| user_id | login_date |\n|---|---|\n| 1 | 2023-01-01 |\n| 1 | 2023-01-02 |\n| 1 | 2023-01-03 |\n| 1 | 2023-01-05 |\n\n**Output**\n\n| user_id |\n|---|\n| 1 |",
    "correctQuery": "WITH Grouped AS (SELECT user_id, login_date, CAST(julianday(login_date) - ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY login_date) AS INTEGER) as grp FROM user_logins) SELECT user_id FROM Grouped GROUP BY user_id, grp HAVING COUNT(*) >= 3;",
    "sourceTableQuery": "CREATE TABLE user_logins (user_id INT, login_date TEXT); INSERT INTO user_logins VALUES (1, '2023-01-01'), (1, '2023-01-02'), (1, '2023-01-03'), (1, '2023-01-05');",
    "hints": [
      "Use the 'Date - Row Number' trick: Convert the date to julianday and subtract the ROW_NUMBER().",
      "For consecutive dates, this calculation yields a constant value which can be used to group the sequence."
    ]
  },
  {
    "id": 44,
    "title": "Expensive Treatments (Top 25%)",
    "difficulty": "Hard",
    "category": "Healthcare",
    "description": "### Problem\nFind the treatments that are in the top 25% of cost within their diagnosis code.\nReturn all columns for the expensive treatments.\n\n### Table: `treatments`\n\n| Column | Type | Description |\n|---|---|---|\n| id | INT | Primary Key |\n| diagnosis_code | TEXT | Code |\n| cost | REAL | Cost |\n\n### Example\n\n**Input**\n\n| id | diagnosis_code | cost |\n|---|---|---|\n| 1 | A | 100 |\n| 2 | A | 200 |\n| 3 | A | 800 |\n| 4 | A | 900 |\n\n**Output**\n\n| id | diagnosis_code | cost |\n|---|---|---|\n| 4 | A | 900 |",
    "correctQuery": "WITH Ranked AS (SELECT id, diagnosis_code, cost, NTILE(4) OVER (PARTITION BY diagnosis_code ORDER BY cost DESC) as quartile FROM treatments) SELECT id, diagnosis_code, cost FROM Ranked WHERE quartile = 1;",
    "sourceTableQuery": "CREATE TABLE treatments (id INT, diagnosis_code TEXT, cost REAL); INSERT INTO treatments VALUES (1, 'A', 100), (2, 'A', 200), (3, 'A', 800), (4, 'A', 900);",
    "hints": [
      "Use the NTILE(4) window function to split data into 4 quartiles based on cost.",
      "Filter the result for the 1st quartile to get the top 25%."
    ]
  },
  {
    "id": 45,
    "title": "Market Basket Analysis",
    "difficulty": "Hard",
    "category": "E-commerce",
    "description": "### Problem\nFind the pair of products that are most frequently bought together in the same order.\nReturn product 1 (`p1`), product 2 (`p2`), and the `frequency`.\nEnsure that `p1` ID is smaller than `p2` ID to avoid duplicates (e.g., A-B and B-A).\n\n### Table: `order_items`\n\n| Column | Type | Description |\n|---|---|---|\n| order_id | INT | Order ID |\n| product_id | INT | Product ID |\n\n### Example\n\n**Input**\n\n| order_id | product_id |\n|---|---|\n| 1 | 10 |\n| 1 | 20 |\n| 2 | 10 |\n| 2 | 20 |\n| 3 | 10 |\n| 3 | 30 |\n\n**Output**\n\n| p1 | p2 | frequency |\n|---|---|---|\n| 10 | 20 | 2 |",
    "correctQuery": "SELECT t1.product_id as p1, t2.product_id as p2, COUNT(*) as frequency FROM order_items t1 JOIN order_items t2 ON t1.order_id = t2.order_id AND t1.product_id < t2.product_id GROUP BY 1, 2 ORDER BY frequency DESC LIMIT 1;",
    "sourceTableQuery": "CREATE TABLE order_items (order_id INT, product_id INT); INSERT INTO order_items VALUES (1, 10), (1, 20), (2, 10), (2, 20), (3, 10), (3, 30);",
    "hints": [
      "Self-join the table on order_id to find items bought in the same order.",
      "Use the condition t1.product_id < t2.product_id to avoid duplicate pairs (e.g., A-B and B-A)."
    ]
  },
  {
    "id": 46,
    "title": "Sessionization",
    "difficulty": "Hard",
    "category": "Social Media",
    "description": "### Problem\nA new session starts if a user is inactive for more than 30 minutes.\nAssign a `session_id` to every event.\nReturn `timestamp` and `session_id` for user 1.\n\n### Table: `events`\n\n| Column | Type | Description |\n|---|---|---|\n| user_id | INT | User ID |\n| timestamp | TEXT | Time (ISO8601) |\n\n### Example\n\n**Input**\n\n| user_id | timestamp |\n|---|---|\n| 1 | 10:00 |\n| 1 | 10:15 |\n| 1 | 11:00 |\n\n**Output**\n\n| timestamp | session_id |\n|---|---|\n| 10:00 | 1 |\n| 10:15 | 1 |\n| 11:00 | 2 |",
    "correctQuery": "WITH Lagged AS (SELECT user_id, timestamp, LAG(timestamp) OVER (PARTITION BY user_id ORDER BY timestamp) as prev_ts FROM events), Flags AS (SELECT user_id, timestamp, CASE WHEN (julianday(timestamp) - julianday(prev_ts)) * 24 * 60 > 30 OR prev_ts IS NULL THEN 1 ELSE 0 END as new_session_flag FROM Lagged) SELECT user_id, timestamp, SUM(new_session_flag) OVER (PARTITION BY user_id ORDER BY timestamp) as session_id FROM Flags;",
    "sourceTableQuery": "CREATE TABLE events (user_id INT, timestamp TEXT); INSERT INTO events VALUES (1, '2023-01-01 10:00:00'), (1, '2023-01-01 10:15:00'), (1, '2023-01-01 11:00:00');",
    "hints": [
      "Calculate the time difference between the current row and the previous row using LAG.",
      "Create a flag (1 or 0) indicating if a new session started, then calculate a running SUM of that flag."
    ]
  },
  {
    "id": 47,
    "title": "Inventory Gaps",
    "difficulty": "Hard",
    "category": "Logistics",
    "description": "### Problem\nFind days where no inventory log was taken between the first and last log date.\nReturn the missing `day`.\n\n### Table: `inventory_logs`\n\n| Column | Type | Description |\n|---|---|---|\n| log_date | TEXT | YYYY-MM-DD |\n| quantity | INT | Qty |\n\n### Example\n\n**Input**\n\n| log_date | quantity |\n|---|---|\n| 2023-01-01 | 10 |\n| 2023-01-03 | 10 |\n\n**Output**\n\n| day |\n|---|\n| 2023-01-02 |",
    "correctQuery": "WITH RECURSIVE DateRange AS (SELECT MIN(log_date) as day FROM inventory_logs UNION ALL SELECT DATE(day, '+1 day') FROM DateRange WHERE day < (SELECT MAX(log_date) FROM inventory_logs)) SELECT d.day FROM DateRange d LEFT JOIN inventory_logs i ON d.day = i.log_date WHERE i.log_date IS NULL;",
    "sourceTableQuery": "CREATE TABLE inventory_logs (log_date TEXT, quantity INT); INSERT INTO inventory_logs VALUES ('2023-01-01', 10), ('2023-01-03', 10);",
    "hints": [
      "Use a Recursive CTE to generate a sequence of dates from the minimum to maximum log date.",
      "Left Join this complete date sequence with the actual logs and filter for NULLs."
    ]
  },
  {
    "id": 48,
    "title": "Churn Rate Calculation",
    "difficulty": "Hard",
    "category": "SaaS",
    "description": "### Problem\nCalculate the churn rate for Jan 2023.\n\n**Definition:**\n* **Denominator:** Users active at the start of Jan (Started before Jan 1 and ended after Jan 1 or never).\n* **Numerator:** Users who churned in Jan (End date is within Jan).\n* **Churn Rate:** (Numerator / Denominator) * 100.\n\n### Table: `subscriptions`\n\n| Column | Type | Description |\n|---|---|---|\n| user_id | INT | User ID |\n| start_date | TEXT | YYYY-MM-DD |\n| end_date | TEXT | YYYY-MM-DD |\n\n### Example\n\n**Input**\n\n| user_id | start_date | end_date |\n|---|---|---|\n| 1 | 2022-12-01 | NULL |\n| 2 | 2022-12-01 | 2023-01-15 |\n\n**Output**\n\n| churn_rate |\n|---|\n| 50.0 |",
    "correctQuery": "WITH StartUsers AS (SELECT COUNT(DISTINCT user_id) as start_count FROM subscriptions WHERE start_date < '2023-01-01' AND (end_date >= '2023-01-01' OR end_date IS NULL)), ChurnedUsers AS (SELECT COUNT(DISTINCT user_id) as churn_count FROM subscriptions WHERE end_date BETWEEN '2023-01-01' AND '2023-01-31') SELECT CAST(churn_count AS DECIMAL) / start_count * 100 as churn_rate FROM StartUsers, ChurnedUsers;",
    "sourceTableQuery": "CREATE TABLE subscriptions (user_id INT, start_date TEXT, end_date TEXT); INSERT INTO subscriptions VALUES (1, '2022-12-01', NULL), (2, '2022-12-01', '2023-01-15');",
    "hints": [
      "Calculate the denominator: users who started before Jan 1st and were still active on Jan 1st.",
      "Calculate the numerator: users whose end_date falls within January."
    ]
  },
  {
    "id": 49,
    "title": "YTD Revenue Growth",
    "difficulty": "Hard",
    "category": "Fintech",
    "description": "### Problem\nCalculate the Year-To-Date (YTD) revenue for each month, resetting at the start of each year.\nReturn the `date` and `ytd_revenue` ordered by date.\n\n### Table: `revenue`\n\n| Column | Type | Description |\n|---|---|---|\n| date | TEXT | YYYY-MM-DD |\n| amount | REAL | Value |\n\n### Example\n\n**Input**\n\n| date | amount |\n|---|---|\n| 2023-01-01 | 100 |\n| 2023-02-01 | 100 |\n\n**Output**\n\n| date | ytd_revenue |\n|---|---|\n| 2023-01-01 | 100 |\n| 2023-02-01 | 200 |",
    "correctQuery": "SELECT date, amount, SUM(amount) OVER (PARTITION BY strftime('%Y', date) ORDER BY date) as ytd_revenue FROM revenue;",
    "sourceTableQuery": "CREATE TABLE revenue (date TEXT, amount REAL); INSERT INTO revenue VALUES ('2023-01-01', 100), ('2023-02-01', 100);",
    "hints": [
      "Use the SUM() window function.",
      "PARTITION BY the year (extracted using strftime('%Y', date)) to reset the running total annually."
    ]
  },
  {
    "id": 50,
    "title": "Weighted Average Price",
    "difficulty": "Hard",
    "category": "E-commerce",
    "description": "### Problem\nCalculate the weighted average price of products sold.\nFormula: `Sum(Price * Quantity) / Sum(Quantity)`.\n\n### Table: `sales`\n\n| Column | Type | Description |\n|---|---|---|\n| price | DECIMAL | Unit Price |\n| quantity | INT | Qty Sold |\n\n### Example\n\n**Input**\n\n| price | quantity |\n|---|---|\n| 10 | 2 |\n| 20 | 1 |\n\n**Output**\n\n| weighted_avg |\n|---|\n| 13.33 |\n*(Calculation: (10*2 + 20*1) / (2+1) = 40/3)*",
    "correctQuery": "SELECT SUM(price * quantity) / SUM(quantity) as weighted_avg FROM sales;",
    "sourceTableQuery": "CREATE TABLE sales (price DECIMAL, quantity INT); INSERT INTO sales VALUES (10, 2), (20, 1);",
    "hints": [
      "The formula for weighted average is Sum(Value * Weight) / Sum(Weights).",
      "In this context, multiply price by quantity for the numerator, and sum the quantity for the denominator."
    ]
  }
]